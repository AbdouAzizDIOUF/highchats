// src/app/pages/saisie-parts/domain/saisie-parts.models.ts

import type { NestedKeys } from '@bpce/ng-subscription-ui/utils';
import type { SAISIE_PARTS_WORDING } from '@app/constants/wording/saisie-parts-wording.constant';

export type SaisiePartsWordingKey = NestedKeys<typeof SAISIE_PARTS_WORDING>;

export interface SocialShareContext {
  /** Montant d'une part */
  shareAmount: number;

  /** Montant minimum autorisé */
  minimumAmount: number;

  /** Montant maximum autorisé (métier : remainingAmountToInvest) */
  maximumAmount: number;

  /** Nombre minimum de parts */
  minimumParts: number;

  /** Nombre maximum de parts (dérivé de maximumAmount / shareAmount) */
  maximumParts: number;

  /** Solde du compte sélectionné (si dispo) */
  accountBalance?: number;

  /** Contrainte “max selon solde compte” (si dispo) */
  maximumAllowedPartsByBalance?: number;
  maximumAllowedAmountByBalance?: number;
}

export interface AmountNormalizationResult {
  rawAmount: number;
  clampedAmount: number;
  nearestMultipleAmount: number;
  roundedAmount: number;
  computedParts: number;
}

export type HelperType = 'none' | 'warning' | 'info';

export interface HelperModel {
  shouldDisplayHelper: boolean;
  helperType: HelperType;
  helperKey: SaisiePartsWordingKey;
  helperAmount: number;
}

export type AmountValidationErrorKey =
  | 'required'
  | 'amountBelowMinimum'
  | 'amountAboveMaximum'
  | 'amountAboveBalance';







// src/app/pages/saisie-parts/domain/saisie-parts.domain.ts

import type { AmountNormalizationResult, HelperModel, SocialShareContext, SaisiePartsWordingKey } from './saisie-parts.models';

const CENTS_RATIO = 100;

export function roundToCents(amount: number): number {
  return Math.round(amount * CENTS_RATIO) / CENTS_RATIO;
}

export function clampAmount(amount: number, minimumAmount: number, maximumAmount: number): number {
  return Math.min(Math.max(amount, minimumAmount), maximumAmount);
}

export function computeNearestMultipleAmount(amount: number, stepAmount: number): number {
  if (!stepAmount) return amount;
  const lowerMultiple = Math.floor(amount / stepAmount) * stepAmount;
  const upperMultiple = Math.ceil(amount / stepAmount) * stepAmount;

  const isLowerCloser = amount - lowerMultiple <= upperMultiple - amount;
  return isLowerCloser ? lowerMultiple : upperMultiple;
}

/**
 * Normalise le montant :
 * - clamp min/max (métier)
 * - rapprochement au multiple le plus proche (UX)
 * - arrondi cents
 * - calc parts
 */
export function normalizeAmountFromContext(
  rawAmount: number,
  socialShareContext: SocialShareContext
): AmountNormalizationResult {
  const clampedAmount = clampAmount(rawAmount, socialShareContext.minimumAmount, socialShareContext.maximumAmount);
  const nearestMultipleAmount = computeNearestMultipleAmount(clampedAmount, socialShareContext.shareAmount);
  const roundedAmount = roundToCents(nearestMultipleAmount);

  const computedParts = socialShareContext.shareAmount
    ? Math.floor(roundedAmount / socialShareContext.shareAmount)
    : 0;

  return {
    rawAmount,
    clampedAmount,
    nearestMultipleAmount,
    roundedAmount,
    computedParts
  };
}

export function computePartsFromAmount(amount: number, shareAmount: number): number {
  if (!shareAmount) return 0;
  return Math.floor(amount / shareAmount);
}

export function clampParts(parts: number, minimumParts: number, maximumParts: number): number {
  return Math.min(Math.max(parts, minimumParts), maximumParts);
}

/**
 * Détermine si on doit afficher un warning "multiple non respecté"
 * (sans invalider le champ, pour laisser l'utilisateur taper).
 */
export function shouldDisplayStepMultipleWarning(
  rawAmount: number,
  socialShareContext: SocialShareContext,
  isInputFocused: boolean
): boolean {
  if (isInputFocused) return false;

  if (!Number.isFinite(rawAmount)) return false;

  const roundedAmount = roundToCents(rawAmount);

  // si hors range => les erreurs min/max/balance s’en chargent
  if (roundedAmount < socialShareContext.minimumAmount) return false;
  if (roundedAmount > socialShareContext.maximumAmount) return false;

  if (
    socialShareContext.maximumAllowedAmountByBalance != null &&
    roundedAmount > socialShareContext.maximumAllowedAmountByBalance
  ) {
    return false;
  }

  // si pas de step
  if (!socialShareContext.shareAmount) return false;

  return roundedAmount % socialShareContext.shareAmount !== 0;
}

/**
 * Convertit erreurs de validation (control.errors) -> helper (message + montant)
 * + fallback warning "step" si demandé
 */
export function computeHelperModel(
  socialShareContext: SocialShareContext,
  validationErrors: Record<string, unknown> | null | undefined,
  shouldDisplayMultipleWarning: boolean
): HelperModel {
  // 1) erreurs prioritaires
  if (validationErrors?.['amountAboveMaximum'] || validationErrors?.['amountAboveBalance']) {
    const helperKey: SaisiePartsWordingKey = 'form.helper.infoAmountMax';
    const helperAmount =
      validationErrors?.['amountAboveBalance']
        ? (socialShareContext.maximumAllowedAmountByBalance ?? socialShareContext.maximumAmount)
        : socialShareContext.maximumAmount;

    return {
      shouldDisplayHelper: true,
      helperType: 'warning',
      helperKey,
      helperAmount
    };
  }

  if (validationErrors?.['amountBelowMinimum']) {
    const helperKey: SaisiePartsWordingKey = 'form.helper.infoAmountMin';
    return {
      shouldDisplayHelper: true,
      helperType: 'warning',
      helperKey,
      helperAmount: socialShareContext.minimumAmount
    };
  }

  // 2) warning UX (multiple)
  if (shouldDisplayMultipleWarning) {
    const helperKey: SaisiePartsWordingKey = 'form.helper.inputErreur';
    return {
      shouldDisplayHelper: true,
      helperType: 'info',
      helperKey,
      helperAmount: socialShareContext.shareAmount
    };
  }

  // 3) helper default info
  return {
    shouldDisplayHelper: false,
    helperType: 'none',
    helperKey: 'form.helper.infoAmount',
    helperAmount: socialShareContext.shareAmount
  };
}




// src/app/pages/saisie-parts/domain/saisie-parts.validators.ts

import type { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';
import type { SocialShareContext } from './saisie-parts.models';
import { roundToCents } from './saisie-parts.domain';

export function socialShareAmountValidator(
  getSocialShareContext: () => SocialShareContext | undefined
): ValidatorFn {
  return (control: AbstractControl): ValidationErrors | null => {
    const socialShareContext = getSocialShareContext();
    if (!socialShareContext) return null;

    const rawAmountValue = Number(control.value);
    if (!Number.isFinite(rawAmountValue)) return { required: true };

    const roundedAmountValue = roundToCents(rawAmountValue);

    if (roundedAmountValue < socialShareContext.minimumAmount) {
      return { amountBelowMinimum: true };
    }

    if (roundedAmountValue > socialShareContext.maximumAmount) {
      return { amountAboveMaximum: true };
    }

    if (
      socialShareContext.maximumAllowedAmountByBalance != null &&
      roundedAmountValue > socialShareContext.maximumAllowedAmountByBalance
    ) {
      return { amountAboveBalance: true };
    }

    return null;
  };
}




import {
  ChangeDetectionStrategy,
  Component,
  DestroyRef,
  OnInit,
  computed,
  effect,
  inject,
  signal
} from '@angular/core';
import { CurrencyPipe } from '@angular/common';
import { FormControl, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router } from '@angular/router';
import { switchMap } from 'rxjs';
import { takeUntilDestroyed, toSignal } from '@angular/core/rxjs-interop';

import { NeoTextHelperComponent } from '@bpce/neo-ng/text-helper';
import { InformationPromptLayoutComponent } from '@bpce/ng-subscription-ui/information-prompt-layout';
import { NeoButtonComponent, NeoButtonGroupComponent } from '@bpce/neo-ng/button';
import { NeoSliderComponent } from '@bpce/neo-ng/slider';
import { NeoCardComponent } from '@bpce/neo-ng/card';
import { NeoDialogModule, NeoDialogService } from '@bpce/neo-ng/dialog';
import { NeoInputAmountComponent } from '@bpce/neo-ng/input-amount';
import { NeoShimmeringComponent } from '@bpce/neo-ng/shimmering';
import { TrackingService } from '@bpce/ng-subscription-services/tracking';
import { BapiStore } from '@bpce/ng-subscription-services/bapi/store';
import { NestedKeys, WordingPipe } from '@bpce/ng-subscription-ui/utils';

import { SAISIE_PARTS_WORDING } from '@app/constants/wording/saisie-parts-wording.constant';
import { SAISIE_PART_PAGE_DATALAYER } from '@app/constants/tracking/tracking.constant';
import { StepRouteEnum } from '@app/routes';
import { BapiStoreService } from '@app/services/store/bapi.store.service';
import { InputStoreService } from '@app/services/store/input.store.service';
import { DigitalParameters } from '@app/models/digital-parameters';

import { PdfViewModalComponent } from '../modals/pdf-view-modal/pdf-view.modal.component';
import { UpdateAmountModalComponent } from '../modals/update-amount-modal/update-amount.modal.component';

import { socialShareAmountValidator } from './domain/saisie-parts.validators';
import {
  clampParts,
  computeHelperModel,
  computePartsFromAmount,
  normalizeAmountFromContext,
  shouldDisplayStepMultipleWarning
} from './domain/saisie-parts.domain';
import type { HelperModel, SocialShareContext } from './domain/saisie-parts.models';

@Component({
  selector: 'app-saisie-parts',
  templateUrl: './saisie-parts.component.html',
  styleUrl: './saisie-parts.component.scss',
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [
    InformationPromptLayoutComponent,
    NeoButtonComponent,
    NeoButtonGroupComponent,
    NeoSliderComponent,
    NeoTextHelperComponent,
    ReactiveFormsModule,
    NeoCardComponent,
    NeoDialogModule,
    NeoInputAmountComponent,
    WordingPipe,
    CurrencyPipe,
    NeoShimmeringComponent
  ]
})
export class SaisiePartsComponent implements OnInit {
  readonly template = SAISIE_PARTS_WORDING;

  private readonly trackingService = inject(TrackingService);
  private readonly neoDialogService = inject(NeoDialogService);
  private readonly destroyRef = inject(DestroyRef);
  private readonly router = inject(Router);
  private readonly bapiStoreService = inject(BapiStoreService);
  private readonly inputStoreService = inject(InputStoreService);
  private readonly bapiStoreParameters: BapiStore<DigitalParameters> = inject(BapiStore);

  protected readonly supportsPdfViewer: boolean = navigator.pdfViewerEnabled;

  /** Etat UI minimal */
  protected readonly isInputFocused = signal(false);
  protected readonly shouldDisplayShimmering = signal(false);
  protected readonly shouldDisplayAmountValue = signal(false);

  /**
   * Contexte métier typé et unique (remplace l’objet “shareData” non typé).
   * IMPORTANT : aucune écriture d’état ici.
   */
  readonly socialShareContext = computed<SocialShareContext | undefined>(() => {
    const socialShareCondition = this.bapiStoreService.conditionSocialShare.value();
    const selectedAccount = this.bapiStoreService.selectedAccount();
    const shareAmount = this.bapiStoreService.shareAmount();

    if (!socialShareCondition || !selectedAccount) return undefined;

    const accountBalance = this.inputStoreService.accountSelected()?.balance;

    const minimumParts = socialShareCondition.characteristics.minimumShareNumber;
    const maximumAmount = socialShareCondition.characteristics.remainingAmountToInvest.value;

    const minimumAmount = minimumParts * selectedAccount.shareAmount.value;
    const maximumParts = Math.floor(maximumAmount / selectedAccount.shareAmount.value);

    const maximumAllowedPartsByBalance =
      accountBalance != null
        ? Math.floor(accountBalance / selectedAccount.shareAmount.value)
        : undefined;

    const maximumAllowedAmountByBalance =
      maximumAllowedPartsByBalance != null
        ? maximumAllowedPartsByBalance * selectedAccount.shareAmount.value
        : undefined;

    return {
      shareAmount,
      minimumAmount,
      maximumAmount,
      minimumParts,
      maximumParts,
      accountBalance,
      maximumAllowedPartsByBalance,
      maximumAllowedAmountByBalance
    };
  });

  /** Formulaire */
  readonly formGroup = new FormGroup({
    input: new FormControl<number | null>(null, {
      validators: [
        Validators.required,
        socialShareAmountValidator(() => this.socialShareContext())
      ]
    })
  });

  /** Signals utilitaires */
  readonly formValueSignal = toSignal(this.formGroup.valueChanges, { initialValue: this.formGroup.value });
  readonly formEventsSignal = toSignal(this.formGroup.events);

  private get inputAmountControl(): FormControl<number | null> {
    return this.formGroup.get('input') as FormControl<number | null>;
  }

  /** Montant courant (fallback sur minimumAmount) */
  readonly currentAmountValue = computed<number>(() => {
    const socialShareContext = this.socialShareContext();
    const rawControlValue = this.inputAmountControl.value;

    if (typeof rawControlValue === 'number' && Number.isFinite(rawControlValue)) {
      return rawControlValue;
    }
    return socialShareContext?.minimumAmount ?? 0;
  });

  /** Nombre de parts correspondant au montant (calculé) */
  readonly selectedPartsNumber = computed<number>(() => {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return 0;

    return computePartsFromAmount(this.currentAmountValue(), socialShareContext.shareAmount);
  });

  /** Précision identique à ton code, mais sans variable intermédiaire */
  readonly inputPrecision = computed<number>(() => {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return 2;

    const isMultipleInteger = Number.isInteger(this.selectedPartsNumber() * socialShareContext.shareAmount);
    if (isMultipleInteger && !this.isInputFocused()) {
      return 0;
    }
    return 2;
  });

  /** Warning step multiple (UX) : ne rend pas le champ invalide */
  readonly shouldDisplayMultipleWarning = computed<boolean>(() => {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return false;

    return shouldDisplayStepMultipleWarning(
      this.currentAmountValue(),
      socialShareContext,
      this.isInputFocused()
    );
  });

  /** Helper “source of truth” (errors + warning multiple) */
  readonly helperModel = computed<HelperModel>(() => {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) {
      return {
        shouldDisplayHelper: false,
        helperType: 'none',
        helperKey: 'form.helper.infoAmount',
        helperAmount: 0
      };
    }

    return computeHelperModel(
      socialShareContext,
      this.inputAmountControl.errors,
      this.shouldDisplayMultipleWarning()
    );
  });

  /** Lien notice */
  public readonly noticeLink = computed(() => {
    return this.bapiStoreParameters.digitalParameters.value()?.links.technicalNoticeLink;
  });

  constructor() {
    /**
     * Quand le contexte arrive, on initialise le champ si vide, et on revalide.
     * Pas d’état “métier” stocké dans le composant.
     */
    effect(() => {
      const socialShareContext = this.socialShareContext();
      if (!socialShareContext) return;

      const currentControlValue = this.inputAmountControl.value;
      const shouldInitialize = currentControlValue == null || currentControlValue === 0;

      if (shouldInitialize) {
        this.inputAmountControl.setValue(socialShareContext.minimumAmount, { emitEvent: false });
      }

      this.inputAmountControl.updateValueAndValidity({ emitEvent: false });
    });

    /**
     * Ton comportement existant : si precision != 0, on “rafraîchit” la valeur.
     */
    effect(() => {
      if (this.inputPrecision() !== 0) {
        this.inputAmountControl.setValue(this.inputAmountControl.value, { emitEvent: false });
      }
    });
  }

  ngOnInit(): void {
    this.trackingService.trackPage(SAISIE_PART_PAGE_DATALAYER);
    this.initializeFromStoreIfNeeded();
  }

  /** blur => snap au multiple le plus proche (uniquement ici) */
  onValueChange(): void {
    this.shouldDisplayShimmering.set(false);
    this.isInputFocused.set(false);

    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return;

    const rawAmountValue = Number(this.inputAmountControl.value);
    if (!Number.isFinite(rawAmountValue)) return;

    const normalizationResult = normalizeAmountFromContext(rawAmountValue, socialShareContext);

    if (normalizationResult.roundedAmount !== rawAmountValue) {
      this.inputAmountControl.setValue(normalizationResult.roundedAmount, { emitEvent: false });
    }

    this.inputAmountControl.updateValueAndValidity({ emitEvent: false });
    this.inputAmountControl.markAsDirty();
    this.shouldDisplayAmountValue.set(!!this.inputAmountControl.value);
  }

  /** input => shimmering uniquement */
  onInputChange(event: any): void {
    const htmlInputElement = event.target as HTMLInputElement;
    const rawAmountValue = Number.parseFloat(htmlInputElement.value);

    this.shouldDisplayShimmering.set(Number.isFinite(rawAmountValue));
  }

  clear(): void {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return;

    this.formGroup.reset({ input: socialShareContext.minimumAmount }, { emitEvent: true });
    this.shouldDisplayAmountValue.set(false);
    this.shouldDisplayShimmering.set(false);
  }

  private initializeFromStoreIfNeeded(): void {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return;

    const storedPartsNumber = this.inputStoreService.shareNumber();
    if (!storedPartsNumber || storedPartsNumber <= 0) return;

    const storedAmountValue = storedPartsNumber * socialShareContext.shareAmount;

    this.inputAmountControl.setValue(storedAmountValue, { emitEvent: false });
    this.inputAmountControl.markAsDirty();
    this.inputAmountControl.updateValueAndValidity({ emitEvent: false });

    this.shouldDisplayAmountValue.set(true);
  }

  openDefault(): void {
    this.neoDialogService
      .open(PdfViewModalComponent)
      .pipe(
        switchMap((ref) => ref.afterClose()),
        takeUntilDestroyed(this.destroyRef)
      )
      .subscribe();
  }

  continue(): void {
    const socialShareContext = this.socialShareContext();
    if (!socialShareContext) return;

    this.inputAmountControl.markAsTouched();
    this.inputAmountControl.updateValueAndValidity();

    if (this.formGroup.invalid) return;

    const validatedAmountValue = Number(this.inputAmountControl.value);
    if (!Number.isFinite(validatedAmountValue)) return;

    // modal si dépassements “max”
    const hasAmountAboveMaximumError = !!this.inputAmountControl.errors?.['amountAboveMaximum'];
    const hasAmountAboveBalanceError = !!this.inputAmountControl.errors?.['amountAboveBalance'];

    if (hasAmountAboveMaximumError || hasAmountAboveBalanceError) {
      this.neoDialogService
        .open(UpdateAmountModalComponent, {
          data: {
            maximumAllowedAmount:
              socialShareContext.maximumAllowedAmountByBalance ?? socialShareContext.maximumAmount,
            maximumAllowedParts:
              socialShareContext.maximumAllowedPartsByBalance ?? socialShareContext.maximumParts
          }
        })
        .pipe(
          switchMap((ref) => ref.afterClose()),
          takeUntilDestroyed(this.destroyRef)
        )
        .subscribe();
      return;
    }

    // calcul parts final + clamp min/max
    const computedPartsNumber = computePartsFromAmount(validatedAmountValue, socialShareContext.shareAmount);
    const finalPartsNumber = clampParts(computedPartsNumber, socialShareContext.minimumParts, socialShareContext.maximumParts);

    this.inputStoreService.setShareNumberSelected(finalPartsNumber);
    this.router.navigate([StepRouteEnum.QUESTION_INTRO]);
  }

  getTitle(): NestedKeys<typeof SAISIE_PARTS_WORDING> {
    const socialShareContext = this.socialShareContext();

    if (!socialShareContext) return 'header.title.default';

    const currentAmountValue = this.formValueSignal().input;
    if (currentAmountValue === socialShareContext.minimumAmount) {
      return 'header.title.default';
    }

    if (!this.formEventsSignal()) {
      return 'header.title.default';
    }

    if (this.formValueSignal().input) {
      this.shouldDisplayAmountValue.set(true);
      return this.shouldDisplayShimmering()
        ? 'header.title.editedShimmering'
        : 'header.title.edited';
    } else {
      this.shouldDisplayAmountValue.set(false);
      return 'header.title.default';
    }
  }
}
